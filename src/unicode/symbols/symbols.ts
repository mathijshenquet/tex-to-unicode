export const commandToCharacter = {
  "leftrightsquigarrow": "↭",
  "Longleftrightarrow": "⟺",
  "blacktriangleright": "▶",
  "longleftrightarrow": "⟷",
  "blacktriangledown": "▼",
  "blacktriangleleft": "◀",
  "leftrightharpoons": "⇋",
  "rightleftharpoons": "⇌",
  "twoheadrightarrow": "↠",
  "circlearrowright": "↻",
  "downharpoonright": "⇂",
  "rightharpoondown": "⇁",
  "rightrightarrows": "⇉",
  "twoheadleftarrow": "↞",
  "vartriangleright": "⊳",
  "bigtriangledown": "▽",
  "circlearrowleft": "↺",
  "curvearrowright": "↷",
  "downharpoonleft": "⇃",
  "leftharpoondown": "↽",
  "leftrightarrows": "⇆",
  "rightleftarrows": "⇄",
  "rightsquigarrow": "⇝",
  "rightthreetimes": "⋌",
  "trianglerighteq": "⊵",
  "vartriangleleft": "⊲",
  "Leftrightarrow": "⇔",
  "Longrightarrow": "⟹",
  "curvearrowleft": "↶",
  "dashrightarrow": "⇢",
  "doublebarwedge": "⩞",
  "downdownarrows": "⇊",
  "hookrightarrow": "↪",
  "leftleftarrows": "⇇",
  "leftrightarrow": "↔",
  "leftthreetimes": "⋋",
  "longrightarrow": "⟶",
  "looparrowright": "↬",
  "rightarrowtail": "↣",
  "rightharpoonup": "⇀",
  "sphericalangle": "∢",
  "textregistered": "®",
  "trianglelefteq": "⊴",
  "upharpoonright": "↾",
  "Longleftarrow": "⟸",
  "bigtriangleup": "△",
  "blacktriangle": "▲",
  "dashleftarrow": "⇠",
  "divideontimes": "⋇",
  "fallingdotseq": "≒",
  "hookleftarrow": "↩",
  "leftarrowtail": "↢",
  "leftharpoonup": "↼",
  "longleftarrow": "⟵",
  "looparrowleft": "↫",
  "measuredangle": "∡",
  "shortparallel": "∥",
  "smallsetminus": "∖",
  "texttrademark": "™",
  "triangleright": "▷",
  "upharpoonleft": "↿",
  "blacklozenge": "◆",
  "risingdotseq": "≓",
  "triangledown": "▽",
  "triangleleft": "◁",
  "Rrightarrow": "⇛",
  "Updownarrow": "⇕",
  "backepsilon": "∍",
  "blacksquare": "■",
  "circledcirc": "⊚",
  "circleddash": "⊝",
  "curlyeqprec": "⋞",
  "curlyeqsucc": "⋟",
  "diamondsuit": "♢",
  "preccurlyeq": "≼",
  "succcurlyeq": "≽",
  "textgreater": ">",
  "thickapprox": "≈",
  "updownarrow": "↕",
  "vartriangle": "△",
  "Lleftarrow": "⇚",
  "Rightarrow": "⇒",
  "circledast": "⊛",
  "complement": "∁",
  "curlywedge": "⋏",
  "longmapsto": "⟼",
  "registered": "®",
  "rightarrow": "→",
  "smallfrown": "⌢",
  "smallsmile": "⌣",
  "sqsubseteq": "⊑",
  "sqsupseteq": "⊒",
  "textlangle": "〈",
  "textrangle": "〉",
  "upuparrows": "⇈",
  "varepsilon": "ε",
  "varnothing": "∅",
  "Downarrow": "⇓",
  "Leftarrow": "⇐",
  "backprime": "‵",
  "bigotimes": "⨂",
  "centerdot": "⋅",
  "copyright": "©",
  "downarrow": "↓",
  "gtreqless": "⋛",
  "heartsuit": "♡",
  "leftarrow": "←",
  "lesseqgtr": "⋚",
  "pitchfork": "⋔",
  "spadesuit": "♠",
  "therefore": "∴",
  "trademark": "™",
  "triangleq": "≜",
  "varpropto": "∝",
  "approxeq": "≊",
  "barwedge": "⊼",
  "bigoplus": "⨁",
  "bigsqcup": "⨆",
  "biguplus": "⨄",
  "bigwedge": "⋀",
  "boxminus": "⊟",
  "boxtimes": "⊠",
  "circledS": "Ⓢ",
  "clubsuit": "♣",
  "curlyvee": "⋎",
  "doteqdot": "≑",
  "emptyset": "∅",
  "intercal": "⊺",
  "leqslant": "⩽",
  "multimap": "⊸",
  "parallel": "∥",
  "setminus": "∖",
  "sqsubset": "⊏",
  "sqsupset": "⊐",
  "subseteq": "⊆",
  "supseteq": "⊇",
  "textless": "<",
  "thicksim": "∼",
  "triangle": "△",
  "varkappa": "ϰ",
  "varsigma": "ς",
  "vartheta": "ϑ",
  "Diamond": "◇",
  "Uparrow": "⇑",
  "Upsilon": "Υ",
  "backsim": "∽",
  "because": "∵",
  "between": "≬",
  "bigcirc": "○",
  "bigodot": "⨀",
  "bigstar": "★",
  "boxplus": "⊞",
  "ddagger": "‡",
  "diamond": "⋄",
  "digamma": "Ϝ",
  "dotplus": "∔",
  "epsilon": "∊",
  "gtrless": "≷",
  "implies": "⇒",
  "leadsto": "↝",
  "lessdot": "⋖",
  "lessgtr": "≶",
  "lesssim": "≲",
  "lozenge": "◊",
  "natural": "♮",
  "nearrow": "↗",
  "nexists": "∄",
  "nwarrow": "↖",
  "partial": "∂",
  "pilcrow": "¶",
  "precsim": "≾",
  "searrow": "↘",
  "section": "§",
  "succsim": "≿",
  "swarrow": "↙",
  "textbar": "|",
  "uparrow": "↑",
  "upsilon": "υ",
  "Bumpeq": "≎",
  "Lambda": "Λ",
  "Subset": "⋐",
  "Supset": "⋑",
  "Vvdash": "⊪",
  "approx": "≈",
  "bigcap": "⋂",
  "bigcup": "⋃",
  "bigvee": "⋁",
  "bowtie": "⋈",
  "boxdot": "⊡",
  "bullet": "∙",
  "bumpeq": "≏",
  "circeq": "≗",
  "coprod": "∐",
  "dagger": "†",
  "daleth": "ד",
  "degree": "°",
  "eqcirc": "≖",
  "exists": "∃",
  "forall": "∀",
  "gtrdot": "⋗",
  "gtrsim": "≳",
  "hslash": "ℏ",
  "lambda": "λ",
  "lfloor": "⌊",
  "ltimes": "⋉",
  "mapsto": "↦",
  "models": "⊨",
  "ominus": "⊖",
  "oslash": "⊘",
  "otimes": "⊗",
  "preceq": "⪯",
  "propto": "∝",
  "rfloor": "⌋",
  "rtimes": "⋊",
  "square": "□",
  "subset": "⊂",
  "succeq": "⪰",
  "supset": "⊃",
  "varphi": "φ",
  "varrho": "ϱ",
  "veebar": "⊻",
  "Delta": "Δ",
  "Gamma": "Γ",
  "Omega": "Ω",
  "Theta": "Θ",
  "Vdash": "⊩",
  "aleph": "ℵ",
  "Alpha": "Α",
  "alpha": "α",
  "angle": "∠",
  "asymp": "≍",
  "cdots": "⋯",
  "cents": "¢",
  "dashv": "⊣",
  "ddots": "⋱",
  "delta": "δ",
  "doteq": "≐",
  "equiv": "≡",
  "frown": "⌢",
  "gamma": "γ",
  "gimel": "ℷ",
  "infty": "∞",
  "kappa": "κ",
  "Kappa": "Κ",
  "lceil": "⌈",
  "nabla": "∇",
  "notin": "∉",
  "omega": "ω",
  "oplus": "⊕",
  "pound": "£",
  "prime": "′",
  "qquad": "  ",
  "rceil": "⌉",
  "sharp": "♯",
  "sigma": "σ",
  "simeq": "≃",
  "smile": "⌣",
  "space": "␣",
  "sqcap": "⊓",
  "sqcup": "⊔",
  "theta": "θ",
  "times": "×",
  "unlhd": "⊴",
  "unrhd": "⊵",
  "uplus": "⊎",
  "vDash": "⊨",
  "varpi": "ϖ",
  "vdash": "⊢",
  "vdots": "⋮",
  "wedge": "∧",
  "Finv": "Ⅎ",
  "Join": "⋈",
  "atop": "¦",
  "beta": "β",
  "Beta": "Β",
  "beth": "ב",
  "cdot": "⋅",
  "circ": "∘",
  "cong": "≅",
  "dots": "…",
  "euro": "€",
  "flat": "♭",
  "geqq": "≧",
  "hbar": "ℏ",
  "iota": "ι",
  "leqq": "≦",
  "odot": "⊙",
  "oint": "∮",
  "perp": "⊥",
  "prec": "≺",
  "prod": "∏",
  "quad": " ",
  "star": "⋆",
  "succ": "≻",
  "surd": "√",
  "zeta": "ζ",
  "Box": "□",
  "Cap": "⋒",
  "Cup": "⋓",
  "Lsh": "↰",
  "Phi": "Φ",
  "Psi": "Ψ",
  "Rsh": "↱",
  "ast": "∗",
  "bot": "⊥",
  "cap": "∩",
  "chi": "χ",
  "Chi": "Χ",
  "cup": "∪",
  "div": "÷",
  "ell": "ℓ",
  "eta": "η",
  "eth": "ð",
  "geq": "≥",
  "ggg": "⋙",
  "int": "∫",
  "leq": "≤",
  "lhd": "⊲",
  "lll": "⋘",
  "mho": "℧",
  "mid": "∣",
  "neg": "¬",
  "neq": "≠",
  "phi": "ϕ",
  "psi": "ψ",
  "rhd": "⊳",
  "rho": "ρ",
  "Rho": "Ρ",
  "sim": "∼",
  "sum": "∑",
  "tau": "τ",
  "Tau": "Τ",
  "top": "⊤",
  "vee": "∨",
  "Im": "ℑ",
  "Pi": "Π",
  "Re": "ℜ",
  "Xi": "Ξ",
  "ge": "≥",
  "gg": "≫",
  "in": "∈",
  "le": "≤",
  "ll": "≪",
  "mp": "∓",
  "mu": "μ",
  "Mu": "Μ",
  "ni": "∋",
  "nu": "ν",
  "Nu": "Ν",
  "pi": "π",
  "pm": "±",
  "wp": "℘",
  "wr": "≀",
  "xi": "ξ",
  "Omicron": "Ο",
  "omicron": "ο" 
};


export type CharacterCommand = keyof typeof commandToCharacter;

export function isCharacterCommand(x: any): x is CharacterCommand {
 return commandToCharacter.hasOwnProperty(x);
}

/**
 * https://tex.stackexchange.com/a/74354/22604
 */
const spaces = {
",": "\u2009", // \, inserts a \thinspace (equivalent to .16667em) in text mode, or \thinmuskip (equivalent to 3mu) in math mode;
\! inserts a negative \thinmuskip in math mode;
\> inserts \medmuskip (equivalent to 4.0mu plus 2.0mu minus 4.0mu) in math mode;
\; inserts \thickmuskip (equivalent to 5.0mu plus 5.0mu) in math mode;
\: is equivalent to \> (see above);
\enspace inserts a space of .5em in text or math mode;
\quad inserts a space of 1em in text or math mode;
\qquad inserts a space of 2em in text or math mode;
\kern <len> inserts a skip of <len> (may be negative) in text or math mode (a plain TeX skip);
\hskip <len> (similar to \kern);
\hspace{<len>} inserts a space of length <len> (may be negative) in math or text mode (a LaTeX \hskip);
\hphantom{<stuff>} inserts space of length equivalent to <stuff> in math or text mode. Should be \protected when used in fragile commands (like \caption and sectional headings);
\  inserts what is called a "control space" (in text or math mode);
  inserts an inter-word space in text mode (and is gobbled in math mode). Similarly for \space and { }.
~ inserts an "unbreakable" space (similar to an HTML &nbsp;) (in text or math mode);
\hfill inserts a so-called "rubber length" or stretch between elements (in text or math mode). Note that you may need to provide a type of anchor to fill from/to; see What is the difference between \hspace*{\fill} and \hfill?;
  ";": "　",
  ",": "　",
  ":": "　",
}

export type SpaceCommand = keyof typeof spaces;

export function isSpaceCommand(x: any): x is SpaceCommand {
 return spaces.hasOwnProperty(x);
}

export function commandToCharacter(command: string): string {
  if(isCharacterCommand(command)) {
    return commandToCharacter[command];
  } else if(isSpaceCommand(command)) {
    return spaces[command];
  } else {
    throw unknownCommandError(command);
  }
}
